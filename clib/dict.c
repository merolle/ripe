// Copyright (C) 2008  Maksim Sipos <msipos@mailc.net>
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

#include "clib/clib.h"

typedef uintptr Flag;
#define BUCKET_EMPTY 0
#define BUCKET_FULL  1

// Get prime that is 2^power-(small number), and is bigger than n.
int64 map_prime(int64 n)
{
  // Size of the sizes[] list.
  #define MAP_PRIMES 27

  // This list was generated by a script that is in closet.
  const uint64 sizes[] = {13, 31, 61, 127, 251, 509, 1021, 2039, 4093, 8191,
                         16381, 32749, 65521, 131071, 262139, 524287,
                         1048573, 2097143, 4194301, 8388593, 16777213,
                         33554393, 67108859, 134217689, 268435399,
                         536870909, 1073741789};

  int i;
  for (i = 0; i < MAP_PRIMES - 1; i++) {
    if (n < sizes[i])
      return sizes[i];
  }

  // Otherwise, return the largest possible hash table size.
  assert_never();
  return sizes[MAP_PRIMES - 1];
}


void dict_init(Dict* d, uint16 key_size, uint16 value_size,
               DictHashFunc hash_func, DictEqualFunc equal_func)
{
  assert(key_size > 0); assert(value_size > 0);

  d->key_size = key_size;
  // key_size_align must be a multiple of sizeof(void*)
  uint16 remainder = key_size % sizeof(void*);
  if (remainder == 0) d->key_size_align = d->key_size;
  else d->key_size_align = d->key_size + sizeof(void*) - remainder;

  d->value_size = value_size;
  remainder = value_size % sizeof(void*);
  if (remainder == 0) d->value_size_align = d->value_size;
  else d->value_size_align = d->value_size + sizeof(void*) - remainder;

  d->total_size = d->key_size_align + d->value_size_align + sizeof(Flag);
  d->hash_func = hash_func;
  d->equal_func = equal_func;
  d->alloc_size = map_prime(0);
  d->size = 0;
  d->data = mem_calloc(d->alloc_size * d->total_size);
}

Dict* dict_new(uint16 key_size, uint16 value_size, DictHashFunc hash_func,
               DictEqualFunc equal_func)
{
  assert(key_size > 0); assert(value_size > 0);
  assert(hash_func != NULL); assert(equal_func != NULL);
  Dict* d = mem_new(Dict);
  dict_init(d, key_size, value_size, hash_func, equal_func);
  return d;
}

static inline void* get_value(Dict* d, void* buckets, uint64 place)
{
  assert(d != NULL); assert(buckets != NULL);
  return buckets + d->total_size * place + sizeof(Flag) + d->key_size_align;
}

static inline void* get_key(Dict* d, void* buckets, uint64 place)
{
  assert(d != NULL); assert(buckets != NULL);
  return buckets + d->total_size * place + sizeof(Flag);
}

static inline Flag* get_flag(Dict* d, void* buckets, uint64 place)
{
  assert(d != NULL); assert(buckets != NULL);
  return ((Flag*) (buckets + d->total_size * place));
}

static void set(Dict* d, void* key, void* value, void* buckets,
                uint64 num_buckets)
{
  assert(d != NULL);
  uint64 hash = d->hash_func(key);
  for (uint64 idx = 0; idx < num_buckets; idx++){
    // Quadratic probing
    uint64 place = (hash + idx*idx) % num_buckets;

    Flag* p_flag = get_flag(d, buckets, place);
    void* dict_key = get_key(d, buckets, place);
    void* dict_value = get_value(d, buckets, place);
    if (*p_flag == BUCKET_EMPTY){
      *p_flag = BUCKET_FULL;
      memcpy(dict_key, key, d->key_size);
      memcpy(dict_value, value, d->value_size);
      return;
    }
    if (d->equal_func(key, dict_key)){
      memcpy(dict_value, value, d->value_size);
    }
  }
  assert_never();
}

void dict_set(Dict* d, void* key, void* value)
{
  if (dict_query(d, key, NULL)){
    set(d, key, value, d->data, d->alloc_size);
  }
  if ((d->size + 1) * 2 >= d->alloc_size){
    // Expand buckets
    uint64 new_size = map_prime(2*(d->size+1));
    void* new_data = mem_calloc(new_size * d->total_size);

    // Rehash each old bucket into new buckets
    for (uint64 i = 0; i < d->alloc_size; i++){
      Flag* p_flag = get_flag(d, d->data, i);
      if (*p_flag == BUCKET_FULL){
        void* old_key = get_key(d, d->data, i);
        void* old_value = get_value(d, d->data, i);
        set(d, old_key, old_value, new_data, new_size);
      }
    }

    // Throw away old stuff
    mem_free(d->data);
    d->alloc_size = new_size;
    d->data = new_data;
  }
  d->size++;
  set(d, key, value, d->data, d->alloc_size);
}

bool dict_query(Dict* d, void* key, void* value)
{
  uint64 hash = d->hash_func(key);

  for (uint64 idx = 0; idx < d->alloc_size; idx++){
    // Quadratic probing
    uint64 place = (hash + idx*idx) % d->alloc_size;

    Flag* p_flag = get_flag(d, d->data, place);
    if (*p_flag == BUCKET_EMPTY){
      return false;
    }

    // Compare keys.
    void* current_key = get_key(d, d->data, place);
    if (d->equal_func(key, current_key)){
      void* current_value = get_value(d, d->data, place);
      if (value != NULL) memcpy(value, current_value, d->value_size);
      return true;
    }
  }

  assert_never();
  return false;
}

bool dict_has_bucket(Dict* d, int64 place)
{
  return (*get_flag(d, d->data, place)) == BUCKET_FULL;
}

void* dict_get_bucket_key(Dict* d, int64 place)
{
  return get_key(d, d->data, place);
}

void* dict_get_bucket_value(Dict* d, int64 place)
{
  return get_value(d, d->data, place);
}

uint64 dict_hash_string(void* key)
{
  return hash_string(*((char**) key));
}

bool dict_equal_string(void* key1, void* key2)
{
  return strcmp( *((char**) key1), *((char**) key2)) == 0;
}

uint64 dict_hash_uint32(void* key)
{
  uint32* p = (uint32*) key;
  return (uint64) *p;
}

bool dict_equal_uint32(void* key1, void* key2)
{
  return (*((uint32*) key1)) == (*((uint32*) key2));
}

uint64 dict_hash_uint64(void* key)
{
  return *((uint64*) key);
}

bool dict_equal_uint64(void* key1, void* key2)
{
  return (*((uint64*) key1)) == (*((uint64*) key2));
}
