class CDataClass
  $
    int64 i;
  $

  constructor new()
    $
      @i = 1;
    $

  virtual_get i()
    return $ int64_to_val(@i) $

  virtual_set i(i)
    $ @i = val_to_int64(__i); $

class Class
  writable filename

  constructor new(filename)
    @filename = filename

  test_filename(test)
    Test.test("basic-class", @filename, test)

operators()
  name = "plus"
  Test.test(name, 1+2,     3)
  Test.test(name, 1.0+2,   3.0)
  Test.test(name, 1+2.0,   3.0)
  Test.test(name, 1.0+2.0, 3.0)
  name = "minus"
  Test.test(name, 1-2,   -1)
  Test.test(name, -1-2,  -3)
  Test.test(name, 2.0-3.0, -1.0)
  name = "times"
  Test.test(name, 2*3,   6)
  Test.test(name, 1.0*3, 3.0)
  name = "div"
  Test.test(name, 3/2,   1)
  Test.test(name, 3/2.0, 1.5)
  name = "bit_and"
  Test.test(name, 7 bit_and 4, 4)
  Test.test(name, 7 bit_and 8, 0)
  Test.test(name, 7 bit_and 1, 1)
  name = "bit_or"
  Test.test(name, 7 bit_or 8, 15)
  Test.test(name, 3 bit_or 4, 7)
  name = "bit_xor"
  Test.test(name, 7 bit_xor 10, 13)
  name = "bit_not"
  Test.test(name, (bit_not 1) bit_and 1, 0)
  name = "modulo"
  Test.test(name, 7 modulo 3, 1)
  Test.test(name, 8 modulo 3, 2)
  name = "exponent"
  Test.test(name, 3^3, 27)
  Test.test(name, 2.0^4.0, 4.0^2.0)
  name = "exponent assoc"
  Test.test(name, 3.0^3.0^3.0, 3.0^27.0)
  name = "precedence"
  Test.test(name, 1 + 2 == 3, true)
  Test.test(name, 1 + 1 < 3, true)

global var_arr = nil

test_vars1(arg1, *arg2)
  Test.test("vararg", arg2.to_string(), var_arr.to_string())

test_vars0(*args)
  Test.test("vararg", args.to_string(), var_arr.to_string())

test_vars3(arg1, arg2, arg3, *args)
  Test.test("vararg", args.to_string(), var_arr.to_string())

vararg()
  var_arr = tuple()
  test_vars1(1)
  var_arr = tuple(2,3)
  test_vars1(1, 2, 3)
  var_arr = tuple(2,3,4,5)
  test_vars1(1, 2, 3, 4, 5)

  var_arr = tuple()
  test_vars0()
  var_arr = tuple(1,2,3)
  test_vars0(1, 2, 3)
  var_arr = tuple(1,2,3,4,5)
  test_vars0(1, 2, 3, 4, 5)

  var_arr = tuple(4,5)
  test_vars3(1, 2, 3, 4, 5)
  var_arr = tuple()
  test_vars3(1, 2, 3)

exceptions()
  val = false
  try
    pass
  catch
    val = true
  Test.test("no throw", val, false)
  #Std.println(" STACK after no throw:")
  #Test.display_stack()

  try
    Test.error()
  catch
    val = true
  Test.test("throw", val, true)
  #Std.println(" STACK after throw:")
  #Test.display_stack()

  n = 0
  try
    Test.error()
  finally
    # Std.println(" finally")
    n = n + 1
  catch
    # Std.println(" catch all")
    n = n + 1
  Test.test("catch+finally", n, 2)
  #Std.println(" STACK after catch+finally:")
  #Test.display_stack()

symbols()
  symbol1 = &some_symbol
  symbol2 = &some_symbol
  Test.test("symbols", symbol1, symbol2)
  Test.test("symbols", symbol1, Integer(symbol2))

parallel()
  a, b = [1, 2, 3]
  Test.test("parallel assign", a, 1)
  Test.test("parallel assign", b, 2)

types()
  name = "is correct type"
  Test.test(name, 1 is Integer, true)
  Test.test(name, "max" is String, true)
  name = "isn't correct type"
  Test.test(name, 1 is Double, false)
  Test.test(name, "max" is Double, false)

switch_helper(x)
  switch x
    case 1
      return 3
    case 2
      return 1
    case 3
      return 2

switcher()
  name = "switch/case"
  Test.test(name, 3, switch_helper(1))
  Test.test(name, 2, switch_helper(3))
  Test.test(name, 1, switch_helper(2))

ellipsis()
  name = ...
    "ellipsis"
  x = ...
      3
  y = ...
      4
  Test.test(name, x+y,
            7)
  y = ...
      4 + ...
      5
  Test.test(name, x+y,
            12)
  y = ( ...
      4 + ...
      6 ...
      )
  Test.test(name, x+y,
            13)

main()
  Test.set_verbose(false)
  operators()
  vararg()
  parallel()
  types()
  switcher()
  ellipsis()

  obj = Class.new("testfile")
  obj.test_filename("testfile")
  Test.test("basic-class", obj.filename, "testfile")
  obj.filename = "hello"
  Test.test("basic-class", obj.filename, "hello")

  obj = CDataClass.new()
  Test.test("constructor", 1, obj.i)
  obj.i = 10
  Test.test("set/get", 10, obj.i)

  #exceptions()
  symbols()

  Test.test("c-expr", $ int64_to_val(1) $, 1)

  Test.test("strings concat", "alpha " "omega", "alpha omega")

  # Integer bitfields
  i = 8
  Test.test("integer bitfield", i.unpack(1, 4), 8)
  Test.test("integer bitfield", i.unpack(1, 3), 0)
  Test.test("integer bitfield", i.unpack(2, 3), 4)
  i = 24
  Test.test("integer bitfield", i.unpack(2, 4), 12)
  Test.test("integer bitfield", i.unpack(5, 1), 1)
  i = i.pack(1, 2, 3)
  Test.test("integer bitfield packing", i, 27)
  # 1 2 3 4 5
  # 1 2 4 8 16
  # 1 1 0 1 1
  i = i.pack(1, 4, 0)
  Test.test("integer bitfield packing", i, 16)

  # Special values of Double's
  inf = Math.INF; Test.test("positive infinity", inf.to_string(), "inf");
  ninf = Math.NINF; Test.test("negative infinity", ninf.to_string(), "-inf");

  # Tally results
  arr = Test.get_results()
  correct = arr[1] - arr[2]
  total = arr[1]
  Err.println("language test results: {}/{}".f(correct, total))
  if correct < total
    Err.println("there were {} errors".f(total - correct))
