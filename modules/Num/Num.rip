namespace Num
  const DOUBLE = $ int64_to_val(NUM_DOUBLE) $
  const INTEGER = $ int64_to_val(NUM_INT) $
  const COMPLEX = $ int64_to_val(NUM_COMPLEX) $

  check_type(type)
      if type != Num.COMPLEX and type != Num.DOUBLE and type != Num.INTEGER
        raise "Invalid Num type: %a".f(type)

  class Array1
    $ NumArray1 a; $

    virtual_get size()
      return $ int64_to_val(@a.size) $

    constructor zeros(Integer sz, Integer type)
      if sz < 1
        raise "Invalid size in Num.Array1.zeros(sz=%a)".f(sz)
      Num.check_type(type)

      $ uint64 size = unpack_int64(__sz);
        int type = unpack_int64(__type);

        @a.size = size; @a.type = type;

        uint64 el_size = sizeof(double);
        if (type == NUM_COMPLEX) el_size = sizeof(double complex);

        @a.data = mem_calloc_atomic(size * el_size); $

    index(Integer x)
      $ int64 x = unpack_int64(__x);
        uint64 size = @a.size;

        if (x < 1 or x > size){
          exc_raise("invalid index (%"PRId64") in array of "
                    "size (%"PRIu64")", x, size);
        }

        switch(@a.type){
          case NUM_DOUBLE:
            return double_to_val(@a.data_double[x-1]);
          case NUM_COMPLEX:
          default:
            assert_never();
        }$

    index_set(Integer x, v)
      $ int64 x = unpack_int64(__x);
        uint64 size = @a.size;

        if (x < 1 or x > size){
          exc_raise("invalid index (%"PRId64") in array of "
                    "size (%"PRIu64")", x, size);
        }

        switch(@a.type){
          case NUM_DOUBLE:
            @a.data_double[x-1] = val_to_double(__v);
          case NUM_COMPLEX:
          default:
            assert_never();
        }$

    # A[x] <- A[x+delta]
    rotate(Integer delta)
      $ const int64 size = @a.size;
        const int type = @a.type;
        int64 delta = unpack_int64(__delta);
        double *data = @a.data_double;

        while (delta < 0) delta += size;
        while (delta >= size) delta -= size;
        if (delta == 0) return VALUE_NIL;

        if (delta < size / 2){
          switch (type){
            case NUM_DOUBLE:
              {
                double temp[delta];
                for (int64 i = 0; i < delta; i++){
                  temp[i] = data[i];
                  data[i] = data[i+delta];
                }
                for (int64 i = delta; i < size - delta; i++){
                  data[i] = data[i+delta];
                }
                for (int64 i = 0; i < delta; i++){
                  data[size - delta + i] = temp[i];
                }
              }
            default:
              assert_never();
          }
        } else {
          delta = delta - size;
          delta = -delta;
          switch (type){
            case NUM_DOUBLE:
              {
                double temp[delta];
                for (int64 i = delta; i >= 0; i--){
                  temp[i] = data[size - delta + i];
                  data[size - delta + i] = data[size - 2*delta + i];
                }
                for (int64 i = size - delta - 1; i >= delta; i--){
                  data[i] = data[i-delta];
                }
                for (int64 i = 0; i < delta; i++){
                  data[i] = temp[i];
                }
              }
            default:
              assert_never();
          }
        } $

  class Array2
    $ NumArray2 a; $

    constructor zeros(Integer x, Integer y, Integer type)
      if x < 1 or y < 1
        raise "Invalid size in Num.Array2.zeros (%ax%a)".f(x, y)
      Num.check_type(type)

      $ uint64 size_x = unpack_int64(__x);
        uint64 size_y = unpack_int64(__y);
        int type = unpack_int64(__type);

        @a.size_x = size_x; @a.size_y = size_y; @a.type = type;
        uint64 total_size = size_x*size_y;

        uint64 el_size = sizeof(double);
        if (type == NUM_COMPLEX) el_size = sizeof(double complex);
        if (type == NUM_INT) el_size = sizeof(int64);

        @a.data = mem_calloc_atomic(total_size * el_size); $

    index(Integer x, Integer y)
      $ int64 x = unpack_int64(__x);
        int64 y = unpack_int64(__y);
        uint64 size_x = @a.size_x;
        uint64 size_y = @a.size_y;

        if (x < 1 or y < 1 or x > size_x or y > size_y){
          exc_raise("invalid index (%"PRId64", %"PRId64") in array of "
                    "size (%"PRIu64" x %"PRIu64")", x, y, size_x, size_y);
        }

        uint64 idx = (y-1)*size_x + x-1;
        switch(@a.type){
          case NUM_DOUBLE:
            return double_to_val(@a.data_double[idx]);
          case NUM_INT:
            return int64_to_val(@a.data_int64[idx]);
          case NUM_COMPLEX:
          default:
            assert_never();
        }$

    index_set(Integer x, Integer y, v)
      $ int64 x = unpack_int64(__x);
        int64 y = unpack_int64(__y);
        uint64 size_x = @a.size_x;
        uint64 size_y = @a.size_y;

        if (x < 1 or y < 1 or x > size_x or y > size_y){
          exc_raise("invalid index (%"PRId64", %"PRId64") in array of "
                    "size (%"PRIu64" x %"PRIu64")", x, y, size_x, size_y);
        }

        uint64 idx = (y-1)*size_x + x-1;
        switch(@a.type){
          case NUM_DOUBLE:
            @a.data_double[idx] = val_to_double(__v);
          case NUM_INT:
            @a.data_int64[idx] = val_to_int64(__v);
          case NUM_COMPLEX:
          default:
            assert_never();
        }$

    virtual_get size_x()
      return $ int64_to_val(@a.size_x) $

    virtual_get size_y()
      return $ int64_to_val(@a.size_y) $

    virtual_get type()
      return $ int64_to_val(@a.type) $
