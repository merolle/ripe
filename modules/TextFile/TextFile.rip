$
  #include <stdio.h>
  #include <errno.h>
  #define TEXTFILE_READ 1
  #define TEXTFILE_WRITE 2
$

namespace TextFile
  const Read = $ int64_to_val(TEXTFILE_READ) $
  const Write = $ int64_to_val(TEXTFILE_WRITE) $

class TextFile
  $ FILE* f; $

  constructor new(filename, mode)
    $
      int64 mode = val_to_int64(__mode);
      const char* smode;
      if (mode == TEXTFILE_READ){
        smode = "r";
      }
      if (mode == TEXTFILE_READ + TEXTFILE_WRITE){
        smode = "rw";
      }
      if (mode == TEXTFILE_WRITE){
        smode = "w";
      }
      const char* filename = val_to_string(__filename);
      @f = fopen(filename, smode);
      if (@f == NULL){
        exc_raise("failed to open '%s'", filename);
      }
    $

  read_line()
    $
      #define FGETS_BUF (100*1024)
      char buf[FGETS_BUF];
      if (@f == NULL){
        exc_raise("attempted to read from a closed file");
      }
      if (fgets(buf, FGETS_BUF, @f) == NULL){
        if (feof(@f)) return VALUE_EOF;
        exc_raise("error while reading from a file");
      }
      return string_to_val(buf);
    $

  read_entire()
    s = nil
    $
      int len;
      fseek(@f, 0, SEEK_END);
      len = ftell(@f);
      fseek(@f, 0, SEEK_SET);
      char* buf = alloca(len + 1);
      buf[len] = 0;
      if (fread(buf, len, 1, @f) != 1){
        exc_raise("failed to read entire file");
      }
      __s = string_to_val(buf);
    $
    return s

  print(text)
    $
      const char* text = val_to_string(__text);
      assert(@f != NULL);
      uint64 len = strlen(text);
      if (len == 0) return VALUE_NIL;
      if (fwrite(text, len, 1, @f) != 1){
        exc_raise("failed to write '%s' to text file: %s", text, strerror(errno));
      }
    $

  println(text)
    self.print(text)
    self.print("\n")

  get_iter()
    return self

  iter()
    return self.read_line()

  close()
    $
      if (@f == NULL){
        exc_raise("attempted to close a closed file");
      }
      fclose(@f);
    $
