$
  #include "clib/stringbuf.h"
$

module String

  #$ rdoc-name String.join
  #$ rdoc-header String.join(Array1 array, String between)
  #$ Joins string elements of array into a string.
  join(array, between)
    if array.size == 0
      return ""
    if array.size == 1
      return array[1]
    s = array[1]
    for el in array[2:]
      s = s + between
      s = s + el
    return s

#$ rdoc-name String
#$ rdoc-header String
#$ A UTF-8 encoded string.
class String
  $
    String s;
  $

  #$ rdoc-name String.new_uniform
  #$ rdoc-header String.new_uniform(Integer c, Integer reps)
  #$ Creates a string of length reps, filled with characters c.
  constructor new_uniform(c, reps)
    $
      int64 reps = val_to_int64(__reps);
      int c = val_to_int64(__c);
      @s.str = mem_malloc(reps + 1);
      for (int64 i = 0; i < reps; i++){
        @s.str[i] = (char) c;
      }
    $

  #$ rdoc-name String.index
  #$ rdoc-header String.index(Integer or Range i)
  #$ Returns a Character (if i is an Integer) or a String, if i is a Range.
  index(i)
    $
      if (obj_klass(__i) == klass_Range){
        Range* range = val_to_range(__i);
        int64 start, finish;
        util_index_range("String",
                         range,
                         strlen(@s.str),
                         &start,
                         &finish);
        if (start <= finish){
          char buf[finish - start + 2];
          memcpy(buf, @s.str + start, finish - start + 1);
          buf[finish - start + 1] = 0;
          return string_to_val(buf);
        } else {
          char buf[start - finish + 2];
          for (int64 i = 0; i < start - finish + 1; i++){
            buf[i] = @s.str[start - i];
          }
          buf[start - finish + 1] = 0;
          return string_to_val(buf);
        }
      }
    $
    return $ int64_to_val(@s.str[util_index("String", val_to_int64(__i), strlen(@s.str))]); $

  #$ rdoc-name String.index_set
  #$ rdoc-header String.index_set(Integer i, Character c)
  #$ Sets the i-th character of a string to c.
  index_set(i, v)
    $
      @s.str[util_index("String", val_to_int64(__i), strlen(@s.str))] = (char) val_to_int64(__v);
    $

  #$ rdoc-name String.overwrite
  #$ rdoc-header String.overwrite(String s)
  #$ Overwrites the contents of the string with that of s.
  overwrite(s)
    $
      char* s = val_to_string(__s);
      if (s == @s.str) return VALUE_NIL;
      mem_free(@s.str);
      @s.str = mem_strdup(s);
    $

  #$ rdoc-name String.to_string
  #$ rdoc-header String.to_string()
  #$ Returns self.
  to_string()
    return self

  #$ rdoc-name String.strip
  #$ rdoc-header String.strip()
  #$ Strips whitespace from left and right ends of the string.
  strip()
    $
      char* s = @s.str;
      while (*s == ' ' or *s == '\t' or *s == '\n') s++;
      int64 n = strlen(s);
      char d[n + 1];
      strcpy(d, s);
      char* p = d + n - 1;
      while (*p == ' ' or *p == '\t' or *p == '\n'){
        *p = 0;
        p--;
      }
    $
    return $ string_to_val(d) $

  #$ rdoc-name String.split
  #$ rdoc-header String.split(chars)
  #$ Splits a string into an Array1.  The String will be split at any occurence
  #$ of chars.  The resulting parts are guaranteed not to have any Characters
  #$ given in chars.
  split(chars)
    arr = []
    word = nil
    $
      char* string = @s.str;
      char* chars = val_to_string(__chars);
      bool in_word = false;
      StringBuf sb;
      sbuf_init(&sb, "");
      while (*string != 0){
        bool whitespace = false;
        if (strchr(chars, *string))
          whitespace = true;
        if (in_word){
          if (whitespace){
    $
    word = $ string_to_val(sb.str) $
    arr.push(word)
    $
            in_word = false;
          } else {
            sbuf_catc(&sb, *string);
          }
        } else {
          if (whitespace){
            /* move on */
          } else {
            sbuf_clear(&sb);
            in_word = true;
            sbuf_catc(&sb, *string);
          }
        }
        string++;
      }
      if (in_word){
    $
    word = $ string_to_val(sb.str) $
    arr.push(word)
    $
      }
      sbuf_deinit(&sb);
    $
    return arr

  #$ rdoc-name String.split_whitespace
  #$ rdoc-header String.split_whitespace()
  #$ Just like String.split(" \n\t")
  split_whitespace()
    return self.split(" \n\t")

  __plus(other)
    $
      const char* other = to_string(__other);
      int bufsize = strlen(@s.str) + strlen(other) + 1;
      char buf[bufsize];
      snprintf(buf, bufsize, "%s%s", @s.str, other);
      return string_to_val(buf);
    $

  __plus2(other)
    $
      const char* other = to_string(__other);
      int bufsize = strlen(@s.str) + strlen(other) + 1;
      char buf[bufsize];
      snprintf(buf, bufsize, "%s%s", other, @s.str);
      return string_to_val(buf);
    $

  replace(map)
    key = nil
    out = nil
    $
      StringBuf sb;

      Format f;
      char* s = @s.str;
      format_init(&f, s);

      FormatElement* data = (FormatElement*) f.array.data;
      sbuf_init(&sb, "");
      for (int64 i = 0; i < f.array.size; i++){
        FormatElement e = data[i];

        switch (e.type){
          case FORMAT_STRING:
            format_get_text(&f, i);
            sbuf_cat(&sb, f.sb.str);
            break;
          case FORMAT_FLAG:
            exc_raise("format flag not allowed");
          case FORMAT_PARAM:
            format_get_text(&f, i);
            __key = string_to_val(f.sb.str);
    $
    str = map[key]
    $
            sbuf_cat(&sb, to_string(__str));
            break;
          default:
            assert_never();
        }
      }

      format_deinit(&f);
      __out = string_to_val(sb.str);
      sbuf_deinit(&sb);
    $
    return out

  #$ rdoc-name String.size
  #$ rdoc-header String.size
  #$ Returns the size (length) of the string.
  virtual_get size()
    $
      char* s = @s.str;
			int l = strlen(s);
			return int64_to_val(l);
    $
