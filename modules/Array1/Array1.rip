#$ rdoc-name Array1
#$ rdoc-header Array1
#$ A one-dimensional array object.

$
  static inline bool cmp(Value cmp_func, Value a, Value b)
  {
    if (cmp_func) {
      return func_call2(cmp_func, a, b) == VALUE_TRUE;
    } else {
      return op_lt(a, b) == VALUE_TRUE;
    }
  }

  void merge_sort(Value* arr, int64 a, int64 b, Value* tmp, Value cmp_func)
  {
    if (a == b) return;
    if (b == a + 1){
      if (cmp(cmp_func, arr[a], arr[b])) return;
      Value t = arr[b];
      arr[b] = arr[a];
      arr[a] = t;
      return;
    }
    const int64 middle = (a+b)/2;
    merge_sort(arr, a, middle, tmp, cmp_func);
    merge_sort(arr, middle+1, b, tmp, cmp_func);

    // Merging step
    int64 left = a;
    int64 right = middle+1;
    int64 t = 0;
    for(;;){
      if (left > middle){
        // Finished with left.
        while (right <= b){
          tmp[t] = arr[right];
          right++; t++;
        }
        break;
      }
      if (right > b){
        // Finished with right.
        while (left <= middle){
          tmp[t] = arr[left];
          left++; t++;
        }
        break;
      }
      if (cmp(cmp_func, arr[left], arr[right])){
        tmp[t] = arr[left];
        left++; t++;
      } else {
        tmp[t] = arr[right];
        right++; t++;
      }
    }

    const int64 sz = b - a + 1;
    for (t = 0; t < sz; t++){
      arr[a+t] = tmp[t];
    }
  }
$

class Array1
  $
    Array1 a;
  $

  #$ rdoc-name Array1.new_const
  #$ rdoc-header Array1.new_const(Integer n, val)
  #$ Create an array of n elements, all of them val.
  constructor new_const(n, val)
    $
      int64 n = val_to_int64(__n);
      @a.size = n;
      @a.alloc_size = n;
      @a.data = mem_malloc(sizeof(Value) * n);
      for (int64 i = 0; i < n; i++){
        @a.data[i] = __val;
      }
    $

  #$ rdoc-name Array1.index
  #$ rdoc-header Array1.index(Integer or Range i)
  #$ If i is an Integer, this returns the i-th element of the Array1.
  #$ If i is a range, this returns a new Array1 that is a slice of self.
  index(i)
    $
      if (obj_klass(__i) == klass_Range){
        Range* range = val_to_range(__i);
        int64 start, finish;
        util_index_range("Array1",
                         range,
                         @a.size,
                         &start,
                         &finish);
        if (start <= finish){
          Value v = array1_new(finish - start + 1);
          Array1* arr = obj_c_data(v);
          for (int64 i = start; i <= finish; i++){
            arr->data[i - start] = @a.data[i];
          }
          return v;
        } else {
          Value v = array1_new(start - finish + 1);
          Array1* arr = obj_c_data(v);
          for (int64 i = 0; i < start - finish + 1; i++){
            arr->data[i] = @a.data[start - i];
          }
          return v;
        }
      }
    $
    return $ array1_index(&(@a), val_to_int64(__i)) $

  #$ rdoc-name Array1.index_set
  #$ rdoc-header Array1.index_set(Integer i, val)
  #$ Sets the i-th element of the array to val.
  index_set(i, val)
    $ array1_index_set(&(@a), val_to_int64(__i), __val); $

  #$ rdoc-name Array1.insert
  #$ rdoc-header Array1.insert(Integer i, val)
  #$ Insert val into position i in the array.  Moves everything in position
  #$ 1 and beyond one step.
  insert(i, val)
    $
      const int64 size = @a.size;
      array1_push(&(@a), __val);
      int64 idx = util_index("Array1",
                             val_to_int64(__i),
                             size);
      Value* data = @a.data;
      for (int64 i = size - 1; i >= idx; i--){
        data[i+1] = data[i];
      }
      data[idx] = __val;
    $

  #$ rdoc-name Array1.push
  #$ rdoc-header Array1.push(val)
  #$ Appends a Value val onto the end of the array. Returns nil.
  push(val)
    $ array1_push(&(@a), __val); $

  #$ rdoc-name Array1.pop
  #$ rdoc-header Array1.pop()
  #$ Removes the last element of the Array1 and returns it.  Throws an
  #$ exception if the Array1 is empty.
  pop()
    return $ array1_pop(&(@a)) $

  #$ rdoc-name Array1.reverse!
  #$ rdoc-header Array1.reverse!()
  #$ Reverse array in place.
  reverse!()
    $
      const int64 sz = @a.size;
      const int64 upto = sz / 2;
      Value* data = @a.data;
      for (int64 i = 0; i < upto; i++){
        Value tmp = data[i];
        int64 j = sz - i - 1;
        data[i] = data[j];
        data[j] = tmp;
      }
    $

  #$ rdoc-name Array1.set_const
  #$ rdoc-header Array1.set_const(val)
  #$ Sets each element of the array to val.
  set_const(val)
    $
      const int64 sz = @a.size;
      for (int64 i = 0; i < sz; i++){
        @a.data[i] = __val;
      }
    $

  #$ rdoc-name Array1.sort!
  #$ rdoc-header Array1.sort!()
  #$ Sort array in place.
  sort!()
    $
      const int64 sz = @a.size;
      if (sz < 2) return VALUE_NIL;
      Value* arr = @a.data;
      Value* tmp = mem_malloc(sizeof(Value) * sz);
      merge_sort(arr, 0, sz-1, tmp, 0);
      mem_free(tmp);
    $

  #$ rdoc-name Array1.sort_via!
  #$ rdoc-header Array1.sort_via!(Function via)
  #$ Sort array in place via a comparison function.  The comparison function
  #$ must accept two elements and answer the question "is element A smaller
  #$ than element B?"
  sort_via!(cmp)
    $
      const int64 sz = @a.size;
      if (sz < 2) return VALUE_NIL;
      Value* arr = @a.data;
      Value* tmp = mem_malloc(sizeof(Value) * sz);
      merge_sort(arr, 0, sz-1, tmp, __cmp);
      mem_free(tmp);
    $

  #$ rdoc-name Array1.swap
  #$ rdoc-header Array1.swap(i, j)
  #$ Swap elements with indices i and j.
  swap(i, j)
    tmp = self[i]
    self[i] = self[j]
    self[j] = tmp

  #$ rdoc-name Array1.to_string
  #$ rdoc-header Array1.to_string()
  #$ Returns a string representation of the array.
  to_string()
    $
      char buf[1024];
      buf[0] = 0;
      strcat(buf, "[");
      for (int i = 0; i < @a.size; i++){
        const char* str = to_string(@a.data[i]);
        strcat(buf, str);
        if (i != @a.size - 1) strcat(buf, ", ");
      }
      strcat(buf, "]");
      return string_to_val(buf);
    $

  #$ rdoc-name Array1.size
  #$ rdoc-header Array1.size
  #$ Returns the size (length) of the Array1.
  virtual_get size()
    return $ int64_to_val(@a.size) $

  #$ rdoc-name Array1.get_iter
  #$ rdoc-header Array1.get_iter()
  #$ Returns an Array1Iterator over self.
  get_iter()
    return Array1Iterator.new(self)

#$ rdoc-name Array1Iterator
#$ rdoc-header Array1Iterator
#$ Iterator object over an Array1 (returns elements of the Array1
#$ sequentially).
class Array1Iterator
  private array
  private idx

  #$ rdoc-name ArrayIterator.new
  #$ rdoc-header ArrayIterator.new(Array1 array)
  #$ Create a new Array1Iterator object over the given array.
  constructor new(array)
    @array = array
    @idx = 1

  #$ rdoc-name Array1.iter
  #$ rdoc-header Array1.iter()
  #$ Returns the next element of the Array1. If you reached the end of the
  #$ Array1, then return eof.
  iter()
    if @idx > @array.size
      return eof
    val = @array[@idx]
    @idx = @idx + 1
    return val
