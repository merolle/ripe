# Copyright (C) 2010  Maksim Sipos <msipos@mailc.net>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# Typedb stores type information during the course of the compilation.
# It is a Map that maps string (name of the typed item) to an array.
# The array contains information about each item that has that name.
#
#  typedb [name]  ->  [
#                       [ token, type, [stuff] ],
#                       [ token, type, [stuff] ],
#                       ...
#                     ]
global typedb = Map.new()

global access_token = nil

namespace Typer
  set_access_token(token)
    access_token = token

  const FUNCTION = 1

  add(name, token, type, item)
    if not typedb.has_key?(name)
      typedb[name] = []
    typedb[name].push( [token, type, item] )

  get(name, type)
    if not typedb.has_key?(name)
      raise "'%a' does not exist in type database".f(name)
    out = []
    for list in typedb[name]
      token = list[1]
      this_type = list[2]
      item = list[3]
      if type == this_type
        if token == nil or token == access_token
          out.push(item)
    if out.size == 0
      raise "'%a' not accessible in type database".f(name)
    return out

  add_function(name, rv_type, param_types)
    Typer.add(name, nil, Typer.FUNCTION, [rv_type, param_types])

  absorb_param_info(param_list)
    out = []
    index = 1
    for param in param_list
      if param.has_string?("array")
        if index != param_list.num_children
          raise "array parameter is not last parameter"
        out.push("*")
      else
        if param.num_children == 1
          out.push(eval_type(param[1]))
        else
          out.push(nil)
      index = index + 1
    return out

  absorb_class(class_name, ast)
    for node in ast
      if node.type == Ast.FUNCTION
        name = class_name + "." + node.get_string("name")
        rv_type = eval_type(node[1])
        param_types = Typer.absorb_param_info(node[2])
        if node.has_string?("annotation")
          if node.get_string("annotation") == "constructor"
            Typer.add_function(name, rv_type, param_types)
        else
          param_types.insert(1, name)
          Typer.add_function(name, rv_type, param_types)

  absorb_info(ast)
    for node in ast
      switch node.type
        case Ast.NAMESPACE
          Namespace.push(node.get_string("name"))
          Typer.absorb_info(node[1])
          Namespace.pop()
        case Ast.FUNCTION
          Typer.add_function(Namespace.prefix() + node.get_string("name"),
                             eval_type(node[1]),
                             Typer.absorb_param_info(node[2]))
        case Ast.CLASS
          Typer.absorb_class(Namespace.prefix() + node.get_string("name"),
                             node[1])

  load_from_file(filename)
    tf = TextFile.new(filename, TextFile.Read)
    text = tf.read_entire()
    tf.close()
    map = Json.parse(text)
    for k, v in map
      if typedb.has_key?(k)
        raise "duplicate key in typedb '%a'".f(k)
      typedb[k] = v

  dump()
    Out.println(Json.encode(typedb))
