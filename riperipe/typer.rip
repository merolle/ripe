# Copyright (C) 2010  Maksim Sipos <msipos@mailc.net>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# typedb is a map of this form:
#   typedb["functions"] = {  "function1" => func_signature,
#                            "Class.function" => func_signature, ... }
#   typedb["classes"] =
#     {
#       "Class"
#         => { "parent" => "ClassName2",
#              "methods" => [ "function", ... ] },
#       ...
#     }
global typedb = { "functions" => Map.new(),
                  "classes" => Map.new() }
global access_token = nil

namespace Typer
  set_access_token(token)
    access_token = token

  get_function(name)
    if not name in typedb["functions"]
      raise "function '{}' does not exist in type database".f(name)
    return typedb["functions"][name]

  add_function(name, rv_type, param_types)
    if name in typedb["functions"]
      raise "duplicate function '{}'".f(name)
    typedb["functions"][name] = [rv_type, param_types]

  absorb_param_info(param_list)
    out = []
    index = 1
    for param in param_list
      if param.has_string?("array")
        if index != param_list.num_children
          raise "array parameter is not last parameter"
        out.push("*")
      else
        out.push(eval_type(param.get_node_optional("type")))
      index = index + 1
    return out

  absorb_class(class_name, ast)
    for node in ast
      if node.type == Ast.FUNCTION
        name = class_name + "." + node.get_string("name")
        rv_type = eval_type(node.get_node_optional("type"))
        param_types = Typer.absorb_param_info(node[1])
        if node.has_string?("annotation")
          if node.get_string("annotation") == "constructor"
            Typer.add_function(name, rv_type, param_types)
        else
          param_types.insert(1, class_name)
          Typer.add_function(name, rv_type, param_types)

  absorb_info(ast)
    for node in ast
      switch node.type
        case Ast.NAMESPACE
          Namespace.push(node.get_string("name"))
          Typer.absorb_info(node[1])
          Namespace.pop()
        case Ast.FUNCTION
          rv_type = eval_type(node.get_node_optional("type"))
          Typer.add_function(Namespace.prefix() + node.get_string("name"),
                             rv_type,
                             Typer.absorb_param_info(node[1]))
        case Ast.CLASS
          Typer.absorb_class(Namespace.prefix() + node.get_string("name"),
                             node[1])

  load_from_file(filename)
    if is_verbose?()
      Err.println("Loading type information from '{}'".f(filename))

    tf = TextFile.new(filename, TextFile.Read)
    text = tf.read_entire()
    tf.close()
    map = Json.parse(text)
    for k, v in map["functions"]
      if k in typedb["functions"]
        raise "duplicate function '{}' defined".f(k)
      typedb["functions"][k] = v
    for k, v in map["classes"]
      if k in typedb["classes"]
        raise "duplicate class '{}' defined".f(k)
      typedb["classes"][k] = v

  dump()
    Out.println(Json.encode(typedb))
