# Copyright (C) 2010  Maksim Sipos <msipos@mailc.net>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

##############################################################################
# Context
##############################################################################

global ctx_class_name, ctx_class_c_name, ctx_class_type, ctx_class_typedef

global ctx_class_dict
namespace Ctx
  class_dict_init()
    ctx_class_dict = Map.new()

  class_dict_get(name)
    if name in ctx_class_dict
      return ctx_class_dict[name]
    field_int_var = "_field_int%a_%a".f(counter(), Util.to_c(name))
    header.print("static int %a;\n".f(field_int_var))
    init2.print("  %a = klass_get_field_int(%a, %a);\n".f(
                        field_int_var,
                        ctx_class_c_name,
                        Dsym.get(name)))
    ctx_class_dict[name] = field_int_var
    return field_int_var

  class_type_get()
    return ctx_class_type

##############################################################################
# Symbol tables
##############################################################################

global ssym_table = Map.new(), dsym_table = Map.new(), type_table = Map.new()

namespace Ssym
  get(name)
    if name in ssym_table
      return ssym_table[name]
    c_name = "_ssym%a_%a".f(counter(), Util.to_c(name))
    header.print("static Value %a;\n".f(c_name))
    init2.print("  %a = ssym_get(\"%a\");\n".f(c_name, name))
    ssym_table[name] = c_name
    return c_name

namespace Dsym
  get(name)
    if name in dsym_table
      return dsym_table[name]
    c_name = "_dsym%a_%a".f(counter(), Util.to_c(name))
    header.print("static Value %a;\n".f(c_name))
    init1.print("  %a = dsym_get(\"%a\");\n".f(c_name, name))
    dsym_table[name] = c_name
    return c_name

namespace Type
  get(name)
    if name in type_table
      return type_table[name]
    c_name = "_klass%a_%a".f(counter(), Util.to_c(name))
    header.print("static Klass* %a;\n".f(c_name))
    init2.print("  %a = klass_get(%a);\n".f(c_name, Dsym.get(name)))
    type_table[name] = c_name
    return c_name

##############################################################################
# Util
##############################################################################
namespace Util
  to_c(ripe_name)
    c_name = ripe_name.clone()
    c_name.substitute_character!('!', '_')
    c_name.substitute_character!('?', '_')
    c_name.substitute_character!('.', '_')
    return c_name

counter()
  cnt = cnt + 1
  return cnt

global cnt = 0

##############################################################################
# Locals
##############################################################################

global locals

class Variable
  writable ripe_name
  writable c_name
  writable type

  constructor new()
    pass

locals_push()
  locals.push(Map.new())

locals_pop()
  locals.pop()

locals_add(c_name, ripe_name, type)
  if locals_query(ripe_name) != nil
    raise "local variable '%a' already registered".f(ripe_name)
  var = Variable.new()
  var.c_name = c_name
  var.ripe_name = ripe_name
  var.type = type
  locals[-1][ripe_name] = var

locals_query(ripe_name)
  if locals.size == 0
    return nil

  for i in (-1):(-(locals.size))
    d = locals[i]
    if ripe_name in d
      return d[ripe_name]
  return nil

##############################################################################
# Generator
##############################################################################

global header, code, init1, init2, init3
global stack

is_vararg?(param_list)
  for param in param_list
    if param.has_string?("array")
      return true
  return false

gen_params2(param_list, first_comma?)
  index = 1
  for param in param_list
    type = nil
    if param.has_string?("array")
      type = "Tuple"
    if param.num_children == 1
      type = eval_type(param[1])

    name = param.get_string("name")
    c_name = "__" + Util.to_c(name)
    locals_add(c_name, name, type)
    if index == 1 and not first_comma?
      code.print("Value " + c_name)
    else
      code.print(", Value " + c_name)
    index = index + 1

gen_params(param_list)
  return gen_params2(param_list, false)

gen_stmt_assign2(lvalue, rvalue)
  right = eval_v_expr(rvalue)
  switch lvalue.type
    case Ast.ID
      var = locals_query(lvalue.text)
      if var == nil
        ripe_name = lvalue.text
        c_name = "__%a".f(Util.to_c(ripe_name))
        type = nil
        code.print("  Value %a = %a;\n".f(c_name, right))
        locals_add(c_name, ripe_name, type)
      else
        code.print("  %a = %a;\n".f(var.c_name, right))
    case Ast.EXPR_TYPED_ID
      ripe_name = lvalue.get_string("name")
      var = locals_query(ripe_name)
      if var == nil
        c_name = "__%a".f(Util.to_c(ripe_name))
        type = nil
        code.print("  Value %a = %a;\n".f(c_name, right))
        locals_add(c_name, ripe_name, type)
      else
        code.print("  %a = %a;\n".f(var.c_name, right))
    case Ast.EXPR_INDEX
      code.print("  %a;\n".f(eval_index_set(lvalue[1],
                                            lvalue[2],
                                            rvalue)))
    case Ast.EXPR_FIELD
      code.print("  field_set(%a, %a, %a);\n".f(
                                        eval_v_expr(lvalue[1]),
                                        Dsym.get(lvalue.get_string("name")),
                                        right) )
    case Ast.EXPR_AT_VAR
      code.print("  %a = %a;\n".f(eval_v_expr(lvalue), right))

gen_stmt_assign(left, right)
  if left.num_children == 1
    gen_stmt_assign2(left[1], right)
  else
    id_tmp = Ast.Node.new_id("_tmp_assign%a".f(counter()))
    gen_stmt_assign2(id_tmp, right)

    index = 1
    for l in left
      gen_stmt_assign2(l,
                       Ast.Node.new_expr_index(id_tmp, [Ast.Node.new_int(index)]))
      index = index + 1

gen_stmt(stmt)
  switch stmt.type
    case Ast.STMT_EXPR
      expr = stmt[1]
      if (expr.type == Ast.EXPR_ID_CALL
       or expr.type == Ast.EXPR_FIELD_CALL
       or expr.type == Ast.C_CODE)
        code.print("  %a;\n".f(eval_v_expr(expr)))
      else
        raise("invalid expression in an expression statement")
    case Ast.STMT_RETURN
      code.print("  return %a;\n".f(eval_v_expr(stmt[1])))
    case Ast.STMT_LOOP
      break_label = "_brk_lbl%a".f(counter())
      continue_label = "_cnt_lbl%a".f(counter())
      code.print("  for(;;){\n  %a:;\n".f(continue_label))
      stack.push(tuple(break_label, continue_label))
      gen_block(stmt[1])
      stack.pop()
      code.print("  }\n")
      code.print("  %a:;\n".f(break_label))
    case Ast.STMT_IF
      code.print("  if (%a == VALUE_TRUE) {\n".f(eval_v_expr(stmt[1])))
      gen_block(stmt[2])
      code.print("  }\n")
    case Ast.STMT_ELIF
      code.print("  else if (%a == VALUE_TRUE) {\n".f(eval_v_expr(stmt[1])))
      gen_block(stmt[2])
      code.print("  }\n")
    case Ast.STMT_ELSE
      code.print("  else {\n")
      gen_block(stmt[1])
      code.print("  }\n")
    case Ast.STMT_BREAK
      if stack.size == 0
        raise "break outside of loop"
      stc = stack[-1]
      code.print("  goto %a;\n".f(stc[1]))
    case Ast.STMT_CONTINUE
      if stack.size == 0
        raise "continue outside of a loop"
      stc = stack[-1]
      code.print("  goto %a;\n".f(stc[2]))
    case Ast.STMT_ASSIGN
      gen_stmt_assign(stmt[1], stmt[2])
    case Ast.STMT_FOR
      lvalue_list = stmt[1]
      expr = stmt[2]
      block = stmt[3]

      # Write the code to get the iterator object.
      id_iterator = Ast.Node.new_id("_iterator%a".f(counter()))
      gen_stmt_assign2(id_iterator, Ast.Node.new_field_call(expr, "get_iter"))

      # Construct the AST to call iter() once
      iter_call = Ast.Node.new_field_call(id_iterator, "iter")

      # Define break and continue labels
      break_label = "_brk_lbl%a".f(counter())
      continue_label = "_cnt_lbl%a".f(counter())

      # Write out the loop
      code.print("  for(;;){\n")
      code.print("%a:;\n".f(continue_label))
      id_temp = Ast.Node.new_id("_iterator_temp%a".f(counter()))
      locals_push()
      gen_stmt_assign2(id_temp, iter_call)
      code.print("  if (%a == VALUE_EOF) break;\n".f(eval_v_expr(id_temp)))
      gen_stmt_assign(lvalue_list, id_temp)
      stack.push(tuple(break_label, continue_label))
      gen_block(block)
      stack.pop()
      locals_pop()
      code.print("  }\n")
      code.print("%a:;\n".f(break_label))

    case Ast.STMT_PASS
      return
    case Ast.STMT_RAISE
      code.print("  exc_raise(val_to_string(%a));".f(
                   eval_v_expr(stmt[1])))
    case Ast.STMT_SWITCH
      c_expr = "_switch_expr%a".f(counter())
      expr = stmt[1]
      case_list = stmt[2]
      code.print("  {\n")
      code.print("  Value %a = %a;\n".f(c_expr, eval_v_expr(expr)))
      index = 1
      for node_case in case_list
        expr = node_case[1]
        block = node_case[2]

        word = "else if"
        if index == 1
          word = "if"
        code.print("  %a (op_equal(%a, %a) == VALUE_TRUE) {\n".f(
                      word,
                      c_expr,
                      eval_v_expr(expr)))
        gen_block(block)
        code.print("  }\n")
      code.print("  }\n")

gen_block(stmt_list)
  locals_push()
  for stmt in stmt_list
    gen_stmt(stmt)
  locals_pop()

gen_function_common2(name, param_num, param_vararg?)
  c_name = "_func%a_%a".f(counter(), Util.to_c(name))
  v_name = "__" + c_name
  init1.print("  Value %a = func%a_to_val(%a);\n".f(v_name,
                                                    param_num,
                                                    c_name))
  init1.print("  ssym_set(\"%a\", %a);\n".f(name, v_name))
  if param_vararg?
    init1.print("  func_set_vararg(%a);\n".f(v_name))

  return tuple(c_name, v_name)

gen_function_common(name, param_list)
  return gen_function_common2(name,
                              param_list.num_children,
                              is_vararg?(param_list))

gen_function(ast)
  name = Namespace.prefix() + ast.get_string("name")
  param_list = ast[2]
  stmt_list = ast[3]

  c_name, v_name = gen_function_common(name, param_list)

  # Generate code
  locals_push()
  code.print("static Value %a(".f(c_name))
  gen_params(param_list)
  code.print("){\n")
  gen_block(stmt_list)
  if stmt_list[-1].type != Ast.STMT_RETURN
    code.print("  return VALUE_NIL;\n")
  code.print("}\n")
  locals_pop()

gen_constructor(Ast.Node ast)
  name = ctx_class_name + "." + ast.get_string("name")
  param_list = ast[2]
  stmt_list = ast[3]

  c_name, v_name = gen_function_common(name, param_list)

  # Generate constructor code
  locals_push()
  code.print("static Value %a(".f(c_name))
  gen_params(param_list)
  code.print("){\n")
  locals_add("__self", "self", ctx_class_name)
  code.print("  %a* _c_data;\n".f(ctx_class_typedef))
  code.print("  Value __self = obj_new(%a, (void**) &_c_data);\n".f(
             ctx_class_c_name))
  gen_block(stmt_list)
  code.print("  return __self;\n")
  code.print("}\n")
  locals_pop()

# Returns v_name of the generated method.
gen_method(String name, Ast.Node ast)
  full_name = ctx_class_name + "." + name
  param_list = ast[2]
  stmt_list = ast[3]

  c_name, v_name = gen_function_common2(full_name,
                                        param_list.num_children + 1,
                                        is_vararg?(param_list))
  dsym_name = Dsym.get(name)
  init1.print("  klass_new_method(%a, %a, %a);\n".f(
                 ctx_class_c_name,
                 dsym_name,
                 v_name))

  # Generate method declaration:
  locals_push()
  code.print("static Value %a(".f(c_name))
  # One special parameter -- self
  locals_add("__self", "self", ctx_class_name)
  code.print("Value __self")
  # Remaining parameters
  gen_params2(param_list, true)
  code.print("){\n")
  # Populate _c_data
  if ctx_class_type == &CDATA or ctx_class_type == &FIELD
    code.print("  %a* _c_data = (%a*) obj_c_data(__self);\n".f(
               ctx_class_typedef,
               ctx_class_typedef))
  gen_block(stmt_list)
  if stmt_list[-1].type != Ast.STMT_RETURN
    code.print("  return VALUE_NIL;\n")
  code.print("}\n")
  locals_pop()
  return v_name

get_class_type(Ast.Node ast)
  c_code = false
  field = false
  for node in ast
    switch node.type
      case Ast.C_CODE
        c_code = true
      case Ast.TL_VAR
        field = true
  if c_code and field
    raise "class '%a' with both cdata and fields".f(ctx_class_name)
  if c_code
    return &CDATA
  if field
    return &FIELD
  return &VIRTUAL

gen_class(Ast.Node node)
  ctx_class_name = Namespace.prefix() + node.get_string("name")
  ctx_class_c_name = "_klass%a_".f(counter())+Util.to_c(ctx_class_name)
  Ctx.class_dict_init()
  header.print("static Klass* %a;\n".f(ctx_class_c_name))
  ast = node[1]
  ctx_class_type = get_class_type(ast)

  # Get these two dynamic symbols first, because we will be writing to init1
  # as well.
  dsym_class = Dsym.get(ctx_class_name)

  # Now, write out class initialization.
  switch ctx_class_type
    case &VIRTUAL
      init1.print("  %a = klass_new(%a, 0);\n".f(
                  ctx_class_c_name, dsym_class))
    case &CDATA
      ctx_class_typedef = "_KlassCData%a_".f(counter()) + Util.to_c(ctx_class_name)
      header.print("typedef struct {\n")
      for n in ast
        if n.type == Ast.C_CODE
          header.print(n.text[2:(-2)])
      header.print("} %a;\n".f(ctx_class_typedef))
      init1.print("  %a = klass_new(%a, sizeof(%a));\n".f(
                  ctx_class_c_name, dsym_class, ctx_class_typedef))
    case &FIELD
      ctx_class_typedef = "Value"
      init1.print("  %a = klass_new(%a, 0);\n".f(
                  ctx_class_c_name, dsym_class))

      # Now iterate over the class AST to find all fields, and initialize them.
      for n in ast
        if n.type == Ast.TL_VAR

          # Map the field type to argument to klass_new_field().
          field_type = ""
          switch n.get_string("annotation")
            case "readable"
              field_type = "FIELD_READABLE"
            case "writable"
              field_type = "FIELD_READABLE | FIELD_WRITABLE"
            case "private"
              field_type = "0"
          optassign_list = n[1]
          for optassign in optassign_list
            dsym_var = Dsym.get(optassign.get_string("name"))
            init1.print("  klass_new_field(%a, %a, %a);\n".f(
                             ctx_class_c_name,
                             dsym_var,
                             field_type))

  # Finally, write out the methods and constructors
  for n in ast
    if n.type == Ast.FUNCTION
      #rv_type = node[1]
      #param_list = node[2]
      #stmt_list = node[3]

      name = n.get_string("name")
      if n.has_string?("annotation")
        switch n.get_string("annotation")
          case "constructor"
            gen_constructor(n)
          case "virtual_set"
            val = gen_method("set_" + name, n)
            dsym = Dsym.get(name)
            init1.print("  klass_new_virtual_writer(%a, %a, %a);\n".f(
                           ctx_class_c_name, dsym, val))
          case "virtual_get"
            val = gen_method("get_" + name, n)
            dsym = Dsym.get(name)
            init1.print("  klass_new_virtual_reader(%a, %a, %a);\n".f(
                           ctx_class_c_name, dsym, val))
      else
        gen_method(name, n)

  ctx_class_typedef = nil
  ctx_class_name = nil
  ctx_class_c_name = nil
  ctx_class_type = nil

gen(ast)
  for node in ast
    switch node.type
      case Ast.NAMESPACE
        Namespace.push(node.get_string("name"))
        gen(node[1])
        Namespace.pop()
      case Ast.C_CODE
        header.print(node.text[2:(-2)])
        header.print("\n")
      case Ast.FUNCTION
        gen_function(node)
      case Ast.CONST_VAR
        for optassign in node[1]
          name = Namespace.prefix() + optassign.get_string("name")
          expr = optassign[1]
          init1.print("  ssym_set(\"%a\", %a);\n".f(name, eval_v_expr(expr)))
      case Ast.CLASS
        gen_class(node)

gen_globals(ast)
  for node in ast
    if node.type == Ast.GLOBAL_VAR
      optassign_list = node[1]
      for optassign in optassign_list
        name = optassign.get_string("name")
        c_name = "_glb%a_%a".f(counter(), Util.to_c(name))
        locals_add(c_name, name, nil)
        header.print("Value %a;\n".f(c_name))
        init3.print("  %a = %a;\n".f(c_name,
                                     eval_v_expr(optassign[1])))

generate(ast, b_header, b_code, b_init1, b_init2, b_init3)
  header = b_header
  code = b_code
  init1 = b_init1
  init2 = b_init2
  init3 = b_init3
  stack = []

  # First layer of locals is for global variables
  locals = []
  locals_push()
  gen_globals(ast)
  gen(ast)
  locals_pop()
